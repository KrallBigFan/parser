Prefix(:=<http://rdf.webofcode.org/woc/>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(xkos:=<http://rdf-vocabulary.ddialliance.org/xkos#>)
Prefix(dcterms:=<http://purl.org/dc/terms/>)


Ontology(<http://rdf.webofcode.org/woc/>
Annotation(rdfs:comment "An ontology that represents object-oriented programming languages"@en)
Annotation(rdfs:label "CodeOntology"@en)

Declaration(Class(:AccessModifier))
Declaration(Class(:ActualArgument))
Declaration(Class(:AnnotationType))
Declaration(Class(:AnonymousClass))
Declaration(Class(:ArrayType))
Declaration(Class(:AssertStatement))
Declaration(Class(:AssignmentExpression))
Declaration(Class(:BlockStatement))
Declaration(Class(:BranchingStatement))
Declaration(Class(:BreakStatement))
Declaration(Class(:CaseLabeledBlock))
Declaration(Class(:CatchBlock))
Declaration(Class(:Class))
Declaration(Class(:ClassDeclarationStatement))
Declaration(Class(:ClassInstanceCreationExpression))
Declaration(Class(:CodeElement))
Declaration(Class(:ComplexType))
Declaration(Class(:Constructor))
Declaration(Class(:ContinueStatement))
Declaration(Class(:ControlFlowStatement))
Declaration(Class(:DecisionMakingStatement))
Declaration(Class(:DeclarationStatement))
Declaration(Class(:DefaultLabeledBlock))
Declaration(Class(:DoStatement))
Declaration(Class(:Enum))
Declaration(Class(:Executable))
Declaration(Class(:ExecutableInvocationExpression))
Declaration(Class(:Expression))
Declaration(Class(:ExpressionStatement))
Declaration(Class(:Field))
Declaration(Class(:FieldDeclarationStatement))
Declaration(Class(:FinallyBlock))
Declaration(Class(:ForEachStatement))
Declaration(Class(:ForStatement))
Declaration(Class(:GradleProject))
Declaration(Class(:IfThenElseStatement))
Declaration(Class(:Interface))
Declaration(Class(:LabeledBlock))
Declaration(Class(:Library))
Declaration(Class(:LocalVariable))
Declaration(Class(:LocalVariableDeclarationStatement))
Declaration(Class(:LoopStatement))
Declaration(Class(:MavenProject))
Declaration(Class(:Method))
Declaration(Class(:MethodInvocationExpression))
Declaration(Class(:Modifiable))
Declaration(Class(:Modifier))
Declaration(Class(:Package))
Declaration(Class(:Parameter))
Declaration(Class(:ParameterizedType))
Declaration(Class(:PrimitiveType))
Declaration(Class(:Project))
Declaration(Class(:ReturnStatement))
Declaration(Class(:Statement))
Declaration(Class(:SwitchStatement))
Declaration(Class(:SynchronizedStatement))
Declaration(Class(:ThrowStatement))
Declaration(Class(:TryStatement))
Declaration(Class(:Type))
Declaration(Class(:TypeArgument))
Declaration(Class(:TypeVariable))
Declaration(Class(:Variable))
Declaration(Class(:VariableDeclarationStatement))
Declaration(Class(:WhileStatement))
Declaration(Class(:Wildcard))
Declaration(ObjectProperty(xkos:generalizes))
Declaration(ObjectProperty(xkos:hasPart))
Declaration(ObjectProperty(xkos:isPartOf))
Declaration(ObjectProperty(xkos:next))
Declaration(ObjectProperty(xkos:previous))
Declaration(ObjectProperty(xkos:specializes))
Declaration(ObjectProperty(:constructs))
Declaration(ObjectProperty(:declares))
Declaration(ObjectProperty(:extends))
Declaration(ObjectProperty(:hasActualTypeArgument))
Declaration(ObjectProperty(:hasAnnotation))
Declaration(ObjectProperty(:hasArgument))
Declaration(ObjectProperty(:hasAssertExpression))
Declaration(ObjectProperty(:hasBody))
Declaration(ObjectProperty(:hasCatchClause))
Declaration(ObjectProperty(:hasCatchFormalParameter))
Declaration(ObjectProperty(:hasCondition))
Declaration(ObjectProperty(:hasConstructor))
Declaration(ObjectProperty(:hasDeclaration))
Declaration(ObjectProperty(:hasDependency))
Declaration(ObjectProperty(:hasElseBranch))
Declaration(ObjectProperty(:hasField))
Declaration(ObjectProperty(:hasFinallyClause))
Declaration(ObjectProperty(:hasForInit))
Declaration(ObjectProperty(:hasForUpdate))
Declaration(ObjectProperty(:hasFormalTypeParameter))
Declaration(ObjectProperty(:hasGenericType))
Declaration(ObjectProperty(:hasInitializer))
Declaration(ObjectProperty(:hasLeftHandSide))
Declaration(ObjectProperty(:hasMethod))
Declaration(ObjectProperty(:hasModifier))
Declaration(ObjectProperty(:hasNextStatement))
Declaration(ObjectProperty(:hasPackage))
Declaration(ObjectProperty(:hasParameter))
Declaration(ObjectProperty(:hasPreviousStatement))
Declaration(ObjectProperty(:hasProject))
Declaration(ObjectProperty(:hasResource))
Declaration(ObjectProperty(:hasReturnType))
Declaration(ObjectProperty(:hasReturnedExpression))
Declaration(ObjectProperty(:hasSubClass))
Declaration(ObjectProperty(:hasSubExpression))
Declaration(ObjectProperty(:hasSubProject))
Declaration(ObjectProperty(:hasSubStatement))
Declaration(ObjectProperty(:hasSuperBound))
Declaration(ObjectProperty(:hasSwitchLabel))
Declaration(ObjectProperty(:hasTarget))
Declaration(ObjectProperty(:hasThenBranch))
Declaration(ObjectProperty(:hasThrownExpression))
Declaration(ObjectProperty(:hasType))
Declaration(ObjectProperty(:hasVariable))
Declaration(ObjectProperty(:implements))
Declaration(ObjectProperty(:invokes))
Declaration(ObjectProperty(:isAnnotationOf))
Declaration(ObjectProperty(:isArrayOf))
Declaration(ObjectProperty(:isAssertExpressionOf))
Declaration(ObjectProperty(:isBodyOf))
Declaration(ObjectProperty(:isCatchClauseOf))
Declaration(ObjectProperty(:isConditionOf))
Declaration(ObjectProperty(:isConstructedBy))
Declaration(ObjectProperty(:isConstructorOf))
Declaration(ObjectProperty(:isDeclaredBy))
Declaration(ObjectProperty(:isDependencyOf))
Declaration(ObjectProperty(:isElseBranchOf))
Declaration(ObjectProperty(:isFieldOf))
Declaration(ObjectProperty(:isFinallyClauseOf))
Declaration(ObjectProperty(:isForInitOf))
Declaration(ObjectProperty(:isForUpdateOf))
Declaration(ObjectProperty(:isImplementedBy))
Declaration(ObjectProperty(:isInitializerOf))
Declaration(ObjectProperty(:isLeftHandSideOf))
Declaration(ObjectProperty(:isMethodOf))
Declaration(ObjectProperty(:isModifierOf))
Declaration(ObjectProperty(:isOverriddenBy))
Declaration(ObjectProperty(:isPackageOf))
Declaration(ObjectProperty(:isParameterOf))
Declaration(ObjectProperty(:isProjectOf))
Declaration(ObjectProperty(:isReferencedBy))
Declaration(ObjectProperty(:isReturnTypeOf))
Declaration(ObjectProperty(:isReturnedBy))
Declaration(ObjectProperty(:isReturnedExpressionOf))
Declaration(ObjectProperty(:isSubExpressionOf))
Declaration(ObjectProperty(:isSubProjectOf))
Declaration(ObjectProperty(:isSubStatementOf))
Declaration(ObjectProperty(:isSwitchLabelOf))
Declaration(ObjectProperty(:isTargetOf))
Declaration(ObjectProperty(:isThenBranchOf))
Declaration(ObjectProperty(:isThrownBy))
Declaration(ObjectProperty(:isThrownExpressionOf))
Declaration(ObjectProperty(:isTypeOf))
Declaration(ObjectProperty(:overrides))
Declaration(ObjectProperty(:references))
Declaration(ObjectProperty(:returns))
Declaration(ObjectProperty(:throws))
Declaration(DataProperty(:hasBuildFile))
Declaration(DataProperty(:hasCanonicalName))
Declaration(DataProperty(:hasDimensions))
Declaration(DataProperty(:hasEndLine))
Declaration(DataProperty(:hasLabel))
Declaration(DataProperty(:hasLine))
Declaration(DataProperty(:hasName))
Declaration(DataProperty(:hasPosition))
Declaration(DataProperty(:hasSimpleName))
Declaration(DataProperty(:hasSourceCode))
Declaration(DataProperty(:hasTargetedLabel))
Declaration(DataProperty(:isVarArgs))
Declaration(NamedIndividual(:Abstract))
Declaration(NamedIndividual(:Boolean))
Declaration(NamedIndividual(:Byte))
Declaration(NamedIndividual(:Char))
Declaration(NamedIndividual(:Default))
Declaration(NamedIndividual(:Double))
Declaration(NamedIndividual(:Final))
Declaration(NamedIndividual(:Float))
Declaration(NamedIndividual(:Int))
Declaration(NamedIndividual(:Long))
Declaration(NamedIndividual(:Private))
Declaration(NamedIndividual(:Protected))
Declaration(NamedIndividual(:Public))
Declaration(NamedIndividual(:Short))
Declaration(NamedIndividual(:Static))
Declaration(NamedIndividual(:Synchronized))
Declaration(NamedIndividual(:Volatile))

############################
#   Object Properties
############################

# Object Property: :constructs (constructs)

AnnotationAssertion(rdfs:comment :constructs "The constructs property relates an executable to the classes it constructs."@en)
AnnotationAssertion(rdfs:label :constructs "constructs"@en)
SubObjectPropertyOf(:constructs :references)
InverseObjectProperties(:constructs :isConstructedBy)
ObjectPropertyDomain(:constructs :Executable)
ObjectPropertyRange(:constructs :Class)

# Object Property: :declares (declares)

AnnotationAssertion(rdfs:comment :declares "The declares property relates a code element to the elements it declares. For instance, a class is linked to its fields, methods and constructors.")
AnnotationAssertion(rdfs:label :declares "declares"@en)
SubObjectPropertyOf(:declares xkos:hasPart)
InverseObjectProperties(:declares :isDeclaredBy)
InverseFunctionalObjectProperty(:declares)
ObjectPropertyDomain(:declares :CodeElement)
ObjectPropertyRange(:declares :CodeElement)

# Object Property: :extends (extends)

AnnotationAssertion(rdfs:comment :extends "The extends property relates a class, an interface, a type variable or a wildacard to the types it extends."@en)
AnnotationAssertion(rdfs:label :extends "extends"@en)
SubObjectPropertyOf(:extends xkos:specializes)
InverseObjectProperties(:extends :hasSubClass)
FunctionalObjectProperty(:extends)
ObjectPropertyDomain(:extends ObjectUnionOf(:Class :Interface :TypeVariable :Wildcard))

# Object Property: :hasActualTypeArgument (has actual type argument)

AnnotationAssertion(rdfs:comment :hasActualTypeArgument "The hasActualTypeArgument property relates a parameterized type to each of its actual type arguments")
AnnotationAssertion(rdfs:label :hasActualTypeArgument "has actual type argument"@en)
ObjectPropertyDomain(:hasActualTypeArgument :ParameterizedType)
ObjectPropertyRange(:hasActualTypeArgument :TypeArgument)

# Object Property: :hasAnnotation (has annotation)

AnnotationAssertion(rdfs:comment :hasAnnotation "The hasAnnotation property relates a code element to its annotations")
AnnotationAssertion(rdfs:label :hasAnnotation "has annotation"@en)
InverseObjectProperties(:hasAnnotation :isAnnotationOf)
ObjectPropertyDomain(:hasAnnotation :CodeElement)
ObjectPropertyRange(:hasAnnotation :AnnotationType)

# Object Property: :hasArgument (has argument)

AnnotationAssertion(rdfs:comment :hasArgument "The hasArgument property relates an executable invocation to each of its actual arguments."@en)
AnnotationAssertion(rdfs:label :hasArgument "has argument"@en)
ObjectPropertyDomain(:hasArgument :ExecutableInvocationExpression)
ObjectPropertyRange(:hasArgument :ActualArgument)

# Object Property: :hasAssertExpression (has assert expression)

AnnotationAssertion(rdfs:comment :hasAssertExpression "The hasAssertExpression property relates an assert statement to the boolean expression asserted to be true"@en)
AnnotationAssertion(rdfs:label :hasAssertExpression "has assert expression"@en)
SubObjectPropertyOf(:hasAssertExpression :hasSubExpression)
InverseObjectProperties(:hasAssertExpression :isAssertExpressionOf)
FunctionalObjectProperty(:hasAssertExpression)
InverseFunctionalObjectProperty(:hasAssertExpression)
ObjectPropertyDomain(:hasAssertExpression :AssertStatement)
ObjectPropertyRange(:hasAssertExpression :Expression)

# Object Property: :hasBody (has body)

AnnotationAssertion(rdfs:comment :hasBody "The hasBody property relates an executable or a statement to its body."@en)
AnnotationAssertion(rdfs:label :hasBody "has body"@en)
SubObjectPropertyOf(:hasBody :hasSubStatement)
InverseObjectProperties(:hasBody :isBodyOf)
FunctionalObjectProperty(:hasBody)
InverseFunctionalObjectProperty(:hasBody)
ObjectPropertyDomain(:hasBody ObjectUnionOf(:Executable :LoopStatement :TryStatement))
ObjectPropertyRange(:hasBody :BlockStatement)

# Object Property: :hasCatchClause (has catch clause)

AnnotationAssertion(rdfs:comment :hasCatchClause "The hasCatchClause property relates a try statement to the relative catch clauses."@en)
AnnotationAssertion(rdfs:label :hasCatchClause "has catch clause"@en)
SubObjectPropertyOf(:hasCatchClause :hasSubStatement)
InverseObjectProperties(:hasCatchClause :isCatchClauseOf)
InverseFunctionalObjectProperty(:hasCatchClause)
ObjectPropertyDomain(:hasCatchClause :TryStatement)
ObjectPropertyRange(:hasCatchClause :CatchBlock)

# Object Property: :hasCatchFormalParameter (has catch formal parameter)

AnnotationAssertion(rdfs:comment :hasCatchFormalParameter "The hasCatchFormalParameter property relates a catch clause to its formal parameters, namely the throwable objects it caughts"@en)
AnnotationAssertion(rdfs:label :hasCatchFormalParameter "has catch formal parameter"@en)
ObjectPropertyDomain(:hasCatchFormalParameter :CatchBlock)
ObjectPropertyRange(:hasCatchFormalParameter :Class)

# Object Property: :hasCondition (has condition)

AnnotationAssertion(rdfs:comment :hasCondition "The hasCondition property specifies a condition for a statement to be executed."@en)
AnnotationAssertion(rdfs:label :hasCondition "has condition"@en)
SubObjectPropertyOf(:hasCondition :hasSubExpression)
InverseObjectProperties(:hasCondition :isConditionOf)
FunctionalObjectProperty(:hasCondition)
InverseFunctionalObjectProperty(:hasCondition)
ObjectPropertyDomain(:hasCondition ObjectUnionOf(:DoStatement :ForStatement :IfThenElseStatement :WhileStatement))
ObjectPropertyRange(:hasCondition :Expression)

# Object Property: :hasConstructor (has constructor)

AnnotationAssertion(rdfs:comment :hasConstructor "The hasConstructor property relates a class to its constructors."@en)
AnnotationAssertion(rdfs:label :hasConstructor "has constructor"@en)
SubObjectPropertyOf(:hasConstructor :declares)
InverseObjectProperties(:hasConstructor :isConstructorOf)
InverseFunctionalObjectProperty(:hasConstructor)
ObjectPropertyDomain(:hasConstructor ObjectUnionOf(:Class :Enum))
ObjectPropertyRange(:hasConstructor :Constructor)

# Object Property: :hasDeclaration (has declaration)

AnnotationAssertion(rdfs:comment :hasDeclaration "The hasDeclaration property relates a variable to the statement it was declared by."@en)
AnnotationAssertion(rdfs:label :hasDeclaration "has declaration"@en)
SubObjectPropertyOf(:hasDeclaration owl:topObjectProperty)
FunctionalObjectProperty(:hasDeclaration)
ObjectPropertyDomain(:hasDeclaration :Variable)
ObjectPropertyRange(:hasDeclaration :VariableDeclarationStatement)

# Object Property: :hasDependency (has dependency)

AnnotationAssertion(rdfs:comment :hasDependency "The hasDependency property relates a project to its dependencies."@en)
AnnotationAssertion(rdfs:label :hasDependency "has dependency"@en)
InverseObjectProperties(:hasDependency :isDependencyOf)
ObjectPropertyDomain(:hasDependency :Project)
ObjectPropertyRange(:hasDependency :Library)

# Object Property: :hasElseBranch (has else branch)

AnnotationAssertion(rdfs:comment :hasElseBranch "The hasElseBranch property relates a if-then-else statement to the statement in the else branch."@en)
AnnotationAssertion(rdfs:label :hasElseBranch "has else branch"@en)
SubObjectPropertyOf(:hasElseBranch :hasSubStatement)
InverseObjectProperties(:hasElseBranch :isElseBranchOf)
FunctionalObjectProperty(:hasElseBranch)
InverseFunctionalObjectProperty(:hasElseBranch)
ObjectPropertyDomain(:hasElseBranch :IfThenElseStatement)
ObjectPropertyRange(:hasElseBranch :Statement)

# Object Property: :hasField (has field)

AnnotationAssertion(rdfs:comment :hasField "The hasField property relates a class to its fields"@en)
AnnotationAssertion(rdfs:label :hasField "has field"@en)
SubObjectPropertyOf(:hasField :declares)
InverseObjectProperties(:hasField :isFieldOf)
InverseFunctionalObjectProperty(:hasField)
ObjectPropertyDomain(:hasField :ComplexType)
ObjectPropertyRange(:hasField :Field)

# Object Property: :hasFinallyClause (has finally clause)

AnnotationAssertion(rdfs:comment :hasFinallyClause "The hasFinallyClause property relates a try statemet to its finally clause."@en)
AnnotationAssertion(rdfs:label :hasFinallyClause "has finally clause"@en)
SubObjectPropertyOf(:hasFinallyClause :hasSubStatement)
InverseObjectProperties(:hasFinallyClause :isFinallyClauseOf)
FunctionalObjectProperty(:hasFinallyClause)
InverseFunctionalObjectProperty(:hasFinallyClause)
ObjectPropertyDomain(:hasFinallyClause :TryStatement)
ObjectPropertyRange(:hasFinallyClause :FinallyBlock)

# Object Property: :hasForInit (has for init)

AnnotationAssertion(rdfs:comment :hasForInit "The hasForInit property relates a basic for statement to each statement expression executed as initialization code, before the first iteration step is performed"@en)
AnnotationAssertion(rdfs:label :hasForInit "has for init"@en)
SubObjectPropertyOf(:hasForInit :hasSubExpression)
InverseObjectProperties(:hasForInit :isForInitOf)
InverseFunctionalObjectProperty(:hasForInit)
ObjectPropertyDomain(:hasForInit :ForStatement)
ObjectPropertyRange(:hasForInit :Expression)

# Object Property: :hasForUpdate (has for update)

AnnotationAssertion(rdfs:comment :hasForUpdate "The hasForUpdate property relates a basic for statement to each expression evaluated as update code at the end of every iteration"@en)
AnnotationAssertion(rdfs:label :hasForUpdate "has for update"@en)
SubObjectPropertyOf(:hasForUpdate :hasSubExpression)
InverseObjectProperties(:hasForUpdate :isForUpdateOf)
InverseFunctionalObjectProperty(:hasForUpdate)
ObjectPropertyDomain(:hasForUpdate :ForStatement)
ObjectPropertyRange(:hasForUpdate :Expression)

# Object Property: :hasFormalTypeParameter (has formal type parameter)

AnnotationAssertion(rdfs:comment :hasFormalTypeParameter "The hasFormalTypeParameter property relates a class, an interface, an enumeration, a constructor or a method to the formal type parameters it declares"@en)
AnnotationAssertion(rdfs:label :hasFormalTypeParameter "has formal type parameter"@en)
ObjectPropertyDomain(:hasFormalTypeParameter ObjectUnionOf(:Class :Enum :Executable :Interface))
ObjectPropertyRange(:hasFormalTypeParameter :TypeVariable)

# Object Property: :hasGenericType (has generic type)

AnnotationAssertion(rdfs:comment :hasGenericType "The hasGenericType property relates a parameterized type to the generic type it is a parameterization of"@en)
AnnotationAssertion(rdfs:label :hasGenericType "has generic type"@en)
FunctionalObjectProperty(:hasGenericType)
ObjectPropertyDomain(:hasGenericType :ParameterizedType)
ObjectPropertyRange(:hasGenericType ObjectUnionOf(:Class :Interface :TypeVariable :Wildcard))

# Object Property: :hasInitializer (has initializer)

AnnotationAssertion(rdfs:comment :hasInitializer "The hasInitializer property relates a variable declaration to the expression assigned to the declared variable"@en)
AnnotationAssertion(rdfs:label :hasInitializer "has initializer"@en)
SubObjectPropertyOf(:hasInitializer :hasSubExpression)
InverseObjectProperties(:hasInitializer :isInitializerOf)
FunctionalObjectProperty(:hasInitializer)
InverseFunctionalObjectProperty(:hasInitializer)
ObjectPropertyDomain(:hasInitializer :VariableDeclarationStatement)
ObjectPropertyRange(:hasInitializer :Expression)

# Object Property: :hasLeftHandSide (has left hand side)

AnnotationAssertion(rdfs:comment :hasLeftHandSide "The hasLeftHandSide property relates a assignement expression to the left hand side expression it contains"@en)
AnnotationAssertion(rdfs:label :hasLeftHandSide "has left hand side"@en)
SubObjectPropertyOf(:hasLeftHandSide :hasSubExpression)
InverseObjectProperties(:hasLeftHandSide :isLeftHandSideOf)
FunctionalObjectProperty(:hasLeftHandSide)
InverseFunctionalObjectProperty(:hasLeftHandSide)
ObjectPropertyDomain(:hasLeftHandSide :AssignmentExpression)
ObjectPropertyRange(:hasLeftHandSide :Expression)

# Object Property: :hasMethod (has method)

AnnotationAssertion(rdfs:comment :hasMethod "The ihasMehtod property relates a class to its methods.")
AnnotationAssertion(rdfs:label :hasMethod "has method"@en)
SubObjectPropertyOf(:hasMethod :declares)
InverseObjectProperties(:hasMethod :isMethodOf)
InverseFunctionalObjectProperty(:hasMethod)
ObjectPropertyDomain(:hasMethod :ComplexType)
ObjectPropertyRange(:hasMethod :Method)

# Object Property: :hasModifier (has modifier)

AnnotationAssertion(rdfs:comment :hasModifier "The hasGenericType property relates a modifiable element to its modifiers"@en)
AnnotationAssertion(rdfs:label :hasModifier "has modifier"@en)
InverseObjectProperties(:hasModifier :isModifierOf)
ObjectPropertyDomain(:hasModifier :Modifiable)
ObjectPropertyRange(:hasModifier :Modifier)

# Object Property: :hasNextStatement (next)

AnnotationAssertion(rdfs:comment :hasNextStatement "The hasNextStatement property relates a statement to the next statement to be executed."@en)
AnnotationAssertion(rdfs:label :hasNextStatement "next"@en)
SubObjectPropertyOf(:hasNextStatement xkos:next)
InverseObjectProperties(:hasNextStatement :hasPreviousStatement)
FunctionalObjectProperty(:hasNextStatement)
InverseFunctionalObjectProperty(:hasNextStatement)
ObjectPropertyDomain(:hasNextStatement :Statement)
ObjectPropertyRange(:hasNextStatement :Statement)

# Object Property: :hasPackage (has package)

AnnotationAssertion(rdfs:comment :hasPackage "The hasPackage property relates a class, interface, enum or annotation to the package it is declared by."@en)
AnnotationAssertion(rdfs:label :hasPackage "has package"@en)
SubObjectPropertyOf(:hasPackage :isDeclaredBy)
InverseObjectProperties(:hasPackage :isPackageOf)
FunctionalObjectProperty(:hasPackage)
ObjectPropertyDomain(:hasPackage ObjectUnionOf(:AnnotationType :ComplexType))
ObjectPropertyRange(:hasPackage :Package)

# Object Property: :hasParameter (has parameter)

AnnotationAssertion(rdfs:comment :hasParameter "The hasParameter property relates a constructor or a method to the formal parameters it declares"@en)
AnnotationAssertion(rdfs:label :hasParameter "has parameter"@en)
InverseObjectProperties(:hasParameter :isParameterOf)
InverseFunctionalObjectProperty(:hasParameter)
ObjectPropertyDomain(:hasParameter :Executable)
ObjectPropertyRange(:hasParameter :Parameter)

# Object Property: :hasPreviousStatement (has previous statement)

AnnotationAssertion(rdfs:comment :hasPreviousStatement "The hasPreviousStatement property relates a statement to the previous one."@en)
AnnotationAssertion(rdfs:label :hasPreviousStatement "has previous statement"@en)
SubObjectPropertyOf(:hasPreviousStatement xkos:previous)
FunctionalObjectProperty(:hasPreviousStatement)
InverseFunctionalObjectProperty(:hasPreviousStatement)
ObjectPropertyDomain(:hasPreviousStatement :Statement)
ObjectPropertyRange(:hasPreviousStatement :Statement)

# Object Property: :hasProject (has project)

AnnotationAssertion(rdfs:comment :hasProject "The hasProject property relates a package to the project it belongs to.")
AnnotationAssertion(rdfs:label :hasProject "has project"@en)
SubObjectPropertyOf(:hasProject xkos:isPartOf)
InverseObjectProperties(:hasProject :isProjectOf)
FunctionalObjectProperty(:hasProject)
ObjectPropertyDomain(:hasProject :Package)
ObjectPropertyRange(:hasProject :Project)

# Object Property: :hasResource (has resource)

AnnotationAssertion(rdfs:comment :hasResource "The hasResource property relates a try statement to each local variable declared to act as resource for the try statement"@en)
AnnotationAssertion(rdfs:label :hasResource "has resource"@en)
ObjectPropertyDomain(:hasResource :TryStatement)
ObjectPropertyRange(:hasResource :LocalVariable)

# Object Property: :hasReturnType (has return type)

AnnotationAssertion(rdfs:comment :hasReturnType "The hasReturnType property relates a method to its return type."@en)
AnnotationAssertion(rdfs:label :hasReturnType "has return type"@en)
SubObjectPropertyOf(:hasReturnType :hasType)
InverseObjectProperties(:hasReturnType :isReturnTypeOf)
FunctionalObjectProperty(:hasReturnType)
ObjectPropertyDomain(:hasReturnType :Method)
ObjectPropertyRange(:hasReturnType :Type)

# Object Property: :hasReturnedExpression (has returned expression)

AnnotationAssertion(rdfs:comment :hasReturnedExpression "The hasReturnedExpression property relates a return statement to the returned expression"@en)
AnnotationAssertion(rdfs:label :hasReturnedExpression "has returned expression"@en)
SubObjectPropertyOf(:hasReturnedExpression :hasSubExpression)
InverseObjectProperties(:hasReturnedExpression :isReturnedExpressionOf)
FunctionalObjectProperty(:hasReturnedExpression)
InverseFunctionalObjectProperty(:hasReturnedExpression)
ObjectPropertyDomain(:hasReturnedExpression :ReturnStatement)
ObjectPropertyRange(:hasReturnedExpression :Expression)

# Object Property: :hasSubClass (has subclass)

AnnotationAssertion(rdfs:comment :hasSubClass "The hasSubClass property relates a class to its direct sub-classes"@en)
AnnotationAssertion(rdfs:label :hasSubClass "has subclass"@en)
SubObjectPropertyOf(:hasSubClass xkos:generalizes)
InverseFunctionalObjectProperty(:hasSubClass)
ObjectPropertyDomain(:hasSubClass ObjectUnionOf(:Class :Interface :TypeVariable :Wildcard))
ObjectPropertyRange(:hasSubClass ObjectUnionOf(:AnnotationType :ComplexType))

# Object Property: :hasSubExpression (has subexpression)

AnnotationAssertion(rdfs:comment :hasSubExpression "The hasSubExpression property relates a statement or expression to the expressions it contains."@en)
AnnotationAssertion(rdfs:label :hasSubExpression "has subexpression"@en)
SubObjectPropertyOf(:hasSubExpression xkos:hasPart)
InverseObjectProperties(:hasSubExpression :isSubExpressionOf)
InverseFunctionalObjectProperty(:hasSubExpression)
ObjectPropertyDomain(:hasSubExpression ObjectUnionOf(:Expression :Statement))
ObjectPropertyRange(:hasSubExpression :Expression)

# Object Property: :hasSubProject (has subproject)

AnnotationAssertion(rdfs:comment :hasSubProject "The hasSubProject property relates a project to its subprojects"@en)
AnnotationAssertion(rdfs:label :hasSubProject "has subproject"@en)
SubObjectPropertyOf(:hasSubProject xkos:hasPart)
InverseObjectProperties(:hasSubProject :isSubProjectOf)
InverseFunctionalObjectProperty(:hasSubProject)
ObjectPropertyDomain(:hasSubProject :Project)
ObjectPropertyRange(:hasSubProject :Project)

# Object Property: :hasSubStatement (has substatement)

AnnotationAssertion(rdfs:comment :hasSubStatement "The hasSubStatement property relates a statment to its sub-statements."@en)
AnnotationAssertion(rdfs:label :hasSubStatement "has substatement"@en)
SubObjectPropertyOf(:hasSubStatement xkos:hasPart)
InverseObjectProperties(:hasSubStatement :isSubStatementOf)
InverseFunctionalObjectProperty(:hasSubStatement)
ObjectPropertyDomain(:hasSubStatement ObjectUnionOf(:Executable :Statement))
ObjectPropertyRange(:hasSubStatement :Statement)

# Object Property: :hasSuperBound (has super bound)

AnnotationAssertion(rdfs:comment :hasSuperBound "The hasSuperBound property relates a lower bounded wildcard to its bouds."@en)
AnnotationAssertion(rdfs:label :hasSuperBound "has super bound"@en)
SubObjectPropertyOf(:hasSuperBound xkos:generalizes)
ObjectPropertyDomain(:hasSuperBound :Wildcard)
ObjectPropertyRange(:hasSuperBound ObjectUnionOf(:Class :Interface :ParameterizedType :TypeVariable))

# Object Property: :hasSwitchLabel (has switch label)

AnnotationAssertion(rdfs:comment :hasSwitchLabel "The hasSwitchLabel property relates a switch statement to its cases."@en)
AnnotationAssertion(rdfs:label :hasSwitchLabel "has switch label"@en)
SubObjectPropertyOf(:hasSwitchLabel :hasSubStatement)
InverseObjectProperties(:hasSwitchLabel :isSwitchLabelOf)
InverseFunctionalObjectProperty(:hasSwitchLabel)
ObjectPropertyDomain(:hasSwitchLabel :SwitchStatement)
ObjectPropertyRange(:hasSwitchLabel :LabeledBlock)

# Object Property: :hasTarget (has target)

AnnotationAssertion(rdfs:comment :hasTarget "The hasTarget property relates a method invocation expression to its target."@en)
AnnotationAssertion(rdfs:label :hasTarget "has target"@en)
SubObjectPropertyOf(:hasTarget :hasSubExpression)
InverseObjectProperties(:hasTarget :isTargetOf)
FunctionalObjectProperty(:hasTarget)
InverseFunctionalObjectProperty(:hasTarget)
ObjectPropertyDomain(:hasTarget :MethodInvocationExpression)
ObjectPropertyRange(:hasTarget :Expression)

# Object Property: :hasThenBranch (has then branch)

AnnotationAssertion(rdfs:comment :hasThenBranch "The hasThenBranch property relates a if-then-else statement to the statement declared in the \"then\" branch"@en)
AnnotationAssertion(rdfs:label :hasThenBranch "has then branch"@en)
SubObjectPropertyOf(:hasThenBranch :hasSubStatement)
InverseObjectProperties(:hasThenBranch :isThenBranchOf)
FunctionalObjectProperty(:hasThenBranch)
InverseFunctionalObjectProperty(:hasThenBranch)
ObjectPropertyDomain(:hasThenBranch :IfThenElseStatement)
ObjectPropertyRange(:hasThenBranch :Statement)

# Object Property: :hasThrownExpression (has thrown expression)

AnnotationAssertion(rdfs:comment :hasThrownExpression "The hasThrownExpression property relates a thrown statement to the expression it throws"@en)
AnnotationAssertion(rdfs:label :hasThrownExpression "has thrown expression"@en)
SubObjectPropertyOf(:hasThrownExpression :hasSubExpression)
InverseObjectProperties(:hasThrownExpression :isThrownExpressionOf)
FunctionalObjectProperty(:hasThrownExpression)
InverseFunctionalObjectProperty(:hasThrownExpression)
ObjectPropertyDomain(:hasThrownExpression :ThrowStatement)
ObjectPropertyRange(:hasThrownExpression :Expression)

# Object Property: :hasType (has type)

AnnotationAssertion(rdfs:comment :hasType "The hasType property relates an expression, a variable or a method to its type."@en)
AnnotationAssertion(rdfs:label :hasType "has type"@en)
InverseObjectProperties(:hasType :isTypeOf)
FunctionalObjectProperty(:hasType)
ObjectPropertyDomain(:hasType ObjectUnionOf(:Expression :Method :Variable))
ObjectPropertyRange(:hasType :Type)

# Object Property: :hasVariable (has variable)

AnnotationAssertion(rdfs:comment :hasVariable "The hasVariable property relates a for-each statement to the local variable it declares."@en)
AnnotationAssertion(rdfs:label :hasVariable "has variable"@en)
FunctionalObjectProperty(:hasVariable)
InverseFunctionalObjectProperty(:hasVariable)
ObjectPropertyDomain(:hasVariable :ForEachStatement)
ObjectPropertyRange(:hasVariable :LocalVariable)

# Object Property: :implements (implements)

AnnotationAssertion(rdfs:comment :implements "The implements property relates a class to each implemented interface."@en)
AnnotationAssertion(rdfs:label :implements "implements"@en)
SubObjectPropertyOf(:implements xkos:specializes)
InverseObjectProperties(:implements :isImplementedBy)
ObjectPropertyDomain(:implements :Class)
ObjectPropertyRange(:implements :Interface)

# Object Property: :invokes (invokes)

AnnotationAssertion(rdfs:comment :invokes "The invokes property relates a invocation expression to the invoked executable."@en)
AnnotationAssertion(rdfs:label :invokes "invokes"@en)
SubObjectPropertyOf(:invokes owl:topObjectProperty)
FunctionalObjectProperty(:invokes)
ObjectPropertyDomain(:invokes :ExecutableInvocationExpression)
ObjectPropertyRange(:invokes :Executable)

# Object Property: :isAnnotationOf (is annotation of)

AnnotationAssertion(rdfs:comment :isAnnotationOf "The isAnnotationOf property relates an annotation to the annotated code element."@en)
AnnotationAssertion(rdfs:label :isAnnotationOf "is annotation of"@en)
ObjectPropertyDomain(:isAnnotationOf :AnnotationType)
ObjectPropertyRange(:isAnnotationOf :CodeElement)

# Object Property: :isArrayOf (is array of)

AnnotationAssertion(rdfs:comment :isArrayOf "The isArrayOf property relates an arrray to the type of its elements at the finest grain. For instance, an array of type \"int[][][]\" is linked to the type \"int\". The number of dimensions of the array is specified by the dimensions property."@en)
AnnotationAssertion(rdfs:label :isArrayOf "is array of"@en)
ObjectPropertyDomain(:isArrayOf :ArrayType)
ObjectPropertyRange(:isArrayOf :Type)

# Object Property: :isAssertExpressionOf (is subexpression of)

AnnotationAssertion(rdfs:comment :isAssertExpressionOf "The isAssertExpressionOf property relates a boolean expression to the assert statement it is contained in."@en)
AnnotationAssertion(rdfs:label :isAssertExpressionOf "is subexpression of"@en)
SubObjectPropertyOf(:isAssertExpressionOf :isSubExpressionOf)
FunctionalObjectProperty(:isAssertExpressionOf)
InverseFunctionalObjectProperty(:isAssertExpressionOf)
ObjectPropertyDomain(:isAssertExpressionOf :Expression)
ObjectPropertyRange(:isAssertExpressionOf :AssertStatement)

# Object Property: :isBodyOf (is body of)

AnnotationAssertion(rdfs:comment :isBodyOf "The isBodyOf property relates a block to the exexcutable or statement it is the body of."@en)
AnnotationAssertion(rdfs:label :isBodyOf "is body of"@en)
SubObjectPropertyOf(:isBodyOf :isSubStatementOf)
FunctionalObjectProperty(:isBodyOf)
InverseFunctionalObjectProperty(:isBodyOf)
ObjectPropertyDomain(:isBodyOf :BlockStatement)
ObjectPropertyRange(:isBodyOf ObjectUnionOf(:Executable :LoopStatement :TryStatement))

# Object Property: :isCatchClauseOf (is catch clause of)

AnnotationAssertion(rdfs:comment :isCatchClauseOf "The isCatchClauseOf property relates a catch clause to the corresponding try statement."@en)
AnnotationAssertion(rdfs:label :isCatchClauseOf "is catch clause of"@en)
SubObjectPropertyOf(:isCatchClauseOf :isSubStatementOf)
FunctionalObjectProperty(:isCatchClauseOf)
ObjectPropertyDomain(:isCatchClauseOf :CatchBlock)
ObjectPropertyRange(:isCatchClauseOf :TryStatement)

# Object Property: :isConditionOf (is condition of)

AnnotationAssertion(rdfs:comment :isConditionOf "The isConditionOf property relates a if-then-else statement or a loop to its condition."@en)
AnnotationAssertion(rdfs:label :isConditionOf "is condition of"@en)
SubObjectPropertyOf(:isConditionOf :isSubExpressionOf)
FunctionalObjectProperty(:isConditionOf)
InverseFunctionalObjectProperty(:isConditionOf)
ObjectPropertyDomain(:isConditionOf :Expression)
ObjectPropertyRange(:isConditionOf ObjectUnionOf(:DoStatement :ForStatement :IfThenElseStatement :WhileStatement))

# Object Property: :isConstructedBy (is constructed by)

AnnotationAssertion(rdfs:comment :isConstructedBy "The isConstructedBy property relates a class to the executables that instantiates objects of that class."@en)
AnnotationAssertion(rdfs:label :isConstructedBy "is constructed by"@en)
SubObjectPropertyOf(:isConstructedBy :isReferencedBy)
ObjectPropertyDomain(:isConstructedBy :Class)
ObjectPropertyRange(:isConstructedBy :Executable)

# Object Property: :isConstructorOf (is constructor of)

AnnotationAssertion(rdfs:comment :isConstructorOf "The isConstructorOf property relates a constructor to the class it is declared by."@en)
AnnotationAssertion(rdfs:label :isConstructorOf "is constructor of"@en)
SubObjectPropertyOf(:isConstructorOf :isDeclaredBy)
FunctionalObjectProperty(:isConstructorOf)
ObjectPropertyDomain(:isConstructorOf :Constructor)
ObjectPropertyRange(:isConstructorOf ObjectUnionOf(:Class :Enum))

# Object Property: :isDeclaredBy (is declared by)

AnnotationAssertion(rdfs:comment :isDeclaredBy "The isDeclaredBy property relates a code element to the element it is declared by."@en)
AnnotationAssertion(rdfs:label :isDeclaredBy "is declared by"@en)
SubObjectPropertyOf(:isDeclaredBy xkos:isPartOf)
FunctionalObjectProperty(:isDeclaredBy)
ObjectPropertyDomain(:isDeclaredBy :CodeElement)
ObjectPropertyRange(:isDeclaredBy :CodeElement)

# Object Property: :isDependencyOf (is dependency of)

AnnotationAssertion(rdfs:comment :isDependencyOf "The isDependencyOf property relates a library to the projects that depend on this library."@en)
AnnotationAssertion(rdfs:label :isDependencyOf "is dependency of"@en)
ObjectPropertyDomain(:isDependencyOf :Library)
ObjectPropertyRange(:isDependencyOf :Project)

# Object Property: :isElseBranchOf (is else branch of)

AnnotationAssertion(rdfs:comment :isElseBranchOf "The isElseBranchOf property relates the statement in an else branch to the corresponding If-then-else statement"@en)
AnnotationAssertion(rdfs:label :isElseBranchOf "is else branch of"@en)
SubObjectPropertyOf(:isElseBranchOf :isSubStatementOf)
FunctionalObjectProperty(:isElseBranchOf)
InverseFunctionalObjectProperty(:isElseBranchOf)
ObjectPropertyDomain(:isElseBranchOf :Statement)
ObjectPropertyRange(:isElseBranchOf :IfThenElseStatement)

# Object Property: :isFieldOf (is field of)

AnnotationAssertion(rdfs:comment :isFieldOf "The isFieldOf property relates a field to the class, interface or enum it is declared by."@en)
AnnotationAssertion(rdfs:label :isFieldOf "is field of"@en)
SubObjectPropertyOf(:isFieldOf :isDeclaredBy)
FunctionalObjectProperty(:isFieldOf)
ObjectPropertyDomain(:isFieldOf :Field)
ObjectPropertyRange(:isFieldOf :ComplexType)

# Object Property: :isFinallyClauseOf (is finally clause of)

AnnotationAssertion(rdfs:comment :isFinallyClauseOf "The isFinallyClauseOf property relates the statement enclosed in a finally clause to the corresponding try statement."@en)
AnnotationAssertion(rdfs:label :isFinallyClauseOf "is finally clause of"@en)
SubObjectPropertyOf(:isFinallyClauseOf :isSubStatementOf)
FunctionalObjectProperty(:isFinallyClauseOf)
InverseFunctionalObjectProperty(:isFinallyClauseOf)
ObjectPropertyDomain(:isFinallyClauseOf :FinallyBlock)
ObjectPropertyRange(:isFinallyClauseOf :TryStatement)

# Object Property: :isForInitOf (is for init of)

AnnotationAssertion(rdfs:comment :isForInitOf "The isForInitOf property relates an expression executed as initialization code of a basic for statement to the relative for statement."@en)
AnnotationAssertion(rdfs:label :isForInitOf "is for init of"@en)
SubObjectPropertyOf(:isForInitOf :isSubExpressionOf)
FunctionalObjectProperty(:isForInitOf)
ObjectPropertyDomain(:isForInitOf :Expression)
ObjectPropertyRange(:isForInitOf :ForStatement)

# Object Property: :isForUpdateOf (is for update of)

AnnotationAssertion(rdfs:comment :isForUpdateOf "The isForUpdateOf property relates an expression evaluated as update code of a for statement at the end of every iteration, to the corresponding for statement."@en)
AnnotationAssertion(rdfs:label :isForUpdateOf "is for update of"@en)
SubObjectPropertyOf(:isForUpdateOf :isSubExpressionOf)
FunctionalObjectProperty(:isForUpdateOf)
ObjectPropertyDomain(:isForUpdateOf :Expression)
ObjectPropertyRange(:isForUpdateOf :ForStatement)

# Object Property: :isImplementedBy (is implemented by)

AnnotationAssertion(rdfs:comment :isImplementedBy "The isImplementedBy property relates an interface to the classes implementig that interface"@en)
AnnotationAssertion(rdfs:label :isImplementedBy "is implemented by"@en)
SubObjectPropertyOf(:isImplementedBy xkos:generalizes)
ObjectPropertyDomain(:isImplementedBy :Interface)
ObjectPropertyRange(:isImplementedBy :Class)

# Object Property: :isInitializerOf (is initializer of)

AnnotationAssertion(rdfs:comment :isInitializerOf "The isInitializerOf property relates an expression used to initialize a variable, to the statement it is contained in."@en)
AnnotationAssertion(rdfs:label :isInitializerOf "is initializer of"@en)
SubObjectPropertyOf(:isInitializerOf :isSubExpressionOf)
FunctionalObjectProperty(:isInitializerOf)
InverseFunctionalObjectProperty(:isInitializerOf)
ObjectPropertyDomain(:isInitializerOf :Expression)
ObjectPropertyRange(:isInitializerOf :VariableDeclarationStatement)

# Object Property: :isLeftHandSideOf (is left hand side of)

AnnotationAssertion(rdfs:comment :isLeftHandSideOf "The isLeftHandSideOf property relates an expression that is used as left hand side expression of an assignemnt, to the corresponding assignment expression"@en)
AnnotationAssertion(rdfs:label :isLeftHandSideOf "is left hand side of"@en)
SubObjectPropertyOf(:isLeftHandSideOf :isSubExpressionOf)
FunctionalObjectProperty(:isLeftHandSideOf)
InverseFunctionalObjectProperty(:isLeftHandSideOf)
ObjectPropertyDomain(:isLeftHandSideOf :Expression)
ObjectPropertyRange(:isLeftHandSideOf :AssignmentExpression)

# Object Property: :isMethodOf (is method of)

AnnotationAssertion(rdfs:comment :isMethodOf "The isMethodOf property relates a method to the class, enum or interface it is declared by."@en)
AnnotationAssertion(rdfs:label :isMethodOf "is method of"@en)
SubObjectPropertyOf(:isMethodOf :isDeclaredBy)
FunctionalObjectProperty(:isMethodOf)
ObjectPropertyDomain(:isMethodOf :Method)
ObjectPropertyRange(:isMethodOf :ComplexType)

# Object Property: :isModifierOf (is modifier of)

AnnotationAssertion(rdfs:comment :isModifierOf "The isModifierOf property relates a modifier to the corresponding modifiable element."@en)
AnnotationAssertion(rdfs:label :isModifierOf "is modifier of"@en)
ObjectPropertyDomain(:isModifierOf :Modifier)
ObjectPropertyRange(:isModifierOf :Modifiable)

# Object Property: :isOverriddenBy (is overridden by)

AnnotationAssertion(rdfs:comment :isOverriddenBy "The isOverridenBy property relates a method to the ones it is overridden by."@en)
AnnotationAssertion(rdfs:label :isOverriddenBy "is overridden by"@en)
SubObjectPropertyOf(:isOverriddenBy xkos:generalizes)
InverseObjectProperties(:isOverriddenBy :overrides)
InverseFunctionalObjectProperty(:isOverriddenBy)
ObjectPropertyDomain(:isOverriddenBy :Method)
ObjectPropertyRange(:isOverriddenBy :Method)

# Object Property: :isPackageOf (is package of)

AnnotationAssertion(rdfs:comment :isPackageOf "The isPackageOf property relates a package to the types it declares."@en)
AnnotationAssertion(rdfs:label :isPackageOf "is package of"@en)
SubObjectPropertyOf(:isPackageOf :declares)
InverseFunctionalObjectProperty(:isPackageOf)
ObjectPropertyDomain(:isPackageOf :Package)
ObjectPropertyRange(:isPackageOf ObjectUnionOf(:AnnotationType :ComplexType))

# Object Property: :isParameterOf (is parameter of)

AnnotationAssertion(rdfs:comment :isParameterOf "The isParameterOf property relates a parameter to the corresponding executable."@en)
AnnotationAssertion(rdfs:label :isParameterOf "is parameter of"@en)
InverseFunctionalObjectProperty(:isParameterOf)
ObjectPropertyDomain(:isParameterOf :Parameter)
ObjectPropertyRange(:isParameterOf :Executable)

# Object Property: :isProjectOf (is project of)

AnnotationAssertion(rdfs:comment :isProjectOf "The isProjectOf property relates a project to the packages it contains."@en)
AnnotationAssertion(rdfs:label :isProjectOf "is project of"@en)
SubObjectPropertyOf(:isProjectOf xkos:hasPart)
InverseFunctionalObjectProperty(:isProjectOf)
ObjectPropertyDomain(:isProjectOf :Project)
ObjectPropertyRange(:isProjectOf :Package)

# Object Property: :isReferencedBy (is referenced by)

AnnotationAssertion(rdfs:comment :isReferencedBy "The isReferencedBy property relates a code element to the elements it is referenced by."@en)
AnnotationAssertion(rdfs:label :isReferencedBy "is referenced by"@en)
InverseObjectProperties(:isReferencedBy :references)
ObjectPropertyDomain(:isReferencedBy :CodeElement)
ObjectPropertyRange(:isReferencedBy :CodeElement)

# Object Property: :isReturnTypeOf (is return type of)

AnnotationAssertion(rdfs:comment :isReturnTypeOf "The isReturnTypeOf property relates a type to the methods that return objects of that type."@en)
AnnotationAssertion(rdfs:label :isReturnTypeOf "is return type of"@en)
SubObjectPropertyOf(:isReturnTypeOf :isTypeOf)
InverseFunctionalObjectProperty(:isReturnTypeOf)
ObjectPropertyDomain(:isReturnTypeOf :Type)
ObjectPropertyRange(:isReturnTypeOf :Method)

# Object Property: :isReturnedBy (is returned by)

AnnotationAssertion(rdfs:comment :isReturnedBy "The isReturnedBy property relates a variable to the methods that return that variable."@en)
AnnotationAssertion(rdfs:label :isReturnedBy "is returned by"@en)
InverseObjectProperties(:isReturnedBy :returns)
InverseFunctionalObjectProperty(:isReturnedBy)
ObjectPropertyDomain(:isReturnedBy :Variable)
ObjectPropertyRange(:isReturnedBy :Method)

# Object Property: :isReturnedExpressionOf (is returned expression of)

AnnotationAssertion(rdfs:comment :isReturnedExpressionOf "The isReturnedExpressionOf property relates an expression returned by a method to the return statement it is contained in."@en)
AnnotationAssertion(rdfs:label :isReturnedExpressionOf "is returned expression of"@en)
SubObjectPropertyOf(:isReturnedExpressionOf :isSubExpressionOf)
FunctionalObjectProperty(:isReturnedExpressionOf)
InverseFunctionalObjectProperty(:isReturnedExpressionOf)
ObjectPropertyDomain(:isReturnedExpressionOf :Expression)
ObjectPropertyRange(:isReturnedExpressionOf :ReturnStatement)

# Object Property: :isSubExpressionOf (is subexpression of)

AnnotationAssertion(rdfs:comment :isSubExpressionOf "The isSubExpressionOf property relates an expression to its parent expression."@en)
AnnotationAssertion(rdfs:label :isSubExpressionOf "is subexpression of"@en)
SubObjectPropertyOf(:isSubExpressionOf xkos:isPartOf)
FunctionalObjectProperty(:isSubExpressionOf)
ObjectPropertyDomain(:isSubExpressionOf :Expression)
ObjectPropertyRange(:isSubExpressionOf ObjectUnionOf(:Expression :Statement))

# Object Property: :isSubProjectOf (is subproject of)

AnnotationAssertion(rdfs:comment :isSubProjectOf "The isSubProjectOf property relates a project to its parent project."@en)
AnnotationAssertion(rdfs:label :isSubProjectOf "is subproject of"@en)
SubObjectPropertyOf(:isSubProjectOf xkos:isPartOf)
FunctionalObjectProperty(:isSubProjectOf)
ObjectPropertyDomain(:isSubProjectOf :Project)
ObjectPropertyRange(:isSubProjectOf :Project)

# Object Property: :isSubStatementOf (is substatement of)

AnnotationAssertion(rdfs:comment :isSubStatementOf "The isSubStatementOf property relates a statement to the method, constructor or statement it is contained in.")
AnnotationAssertion(rdfs:label :isSubStatementOf "is substatement of"@en)
SubObjectPropertyOf(:isSubStatementOf xkos:isPartOf)
ObjectPropertyDomain(:isSubStatementOf :Statement)
ObjectPropertyRange(:isSubStatementOf ObjectUnionOf(:Executable :Statement))

# Object Property: :isSwitchLabelOf (is switch label of)

AnnotationAssertion(rdfs:comment :isSwitchLabelOf "The isSwitchLabelOf property relates a case labeled block or a default block to the corresponding switch statement."@en)
AnnotationAssertion(rdfs:label :isSwitchLabelOf "is switch label of"@en)
SubObjectPropertyOf(:isSwitchLabelOf :isSubStatementOf)
FunctionalObjectProperty(:isSwitchLabelOf)
ObjectPropertyDomain(:isSwitchLabelOf :LabeledBlock)
ObjectPropertyRange(:isSwitchLabelOf :SwitchStatement)

# Object Property: :isTargetOf (is target of)

AnnotationAssertion(rdfs:comment :isTargetOf "The isTargetOf property relates an expression used as target of a method invocation, to the corresponding method invocation."@en)
AnnotationAssertion(rdfs:label :isTargetOf "is target of"@en)
SubObjectPropertyOf(:isTargetOf :isSubExpressionOf)
FunctionalObjectProperty(:isTargetOf)
InverseFunctionalObjectProperty(:isTargetOf)
ObjectPropertyDomain(:isTargetOf :Expression)
ObjectPropertyRange(:isTargetOf :MethodInvocationExpression)

# Object Property: :isThenBranchOf (is then branch of)

AnnotationAssertion(rdfs:comment :isThenBranchOf "The isThenBranchOf property relates a statement enclosed in a then branch to the corresponding If-then-else statement"@en)
AnnotationAssertion(rdfs:label :isThenBranchOf "is then branch of"@en)
SubObjectPropertyOf(:isThenBranchOf :isSubStatementOf)
FunctionalObjectProperty(:isThenBranchOf)
InverseFunctionalObjectProperty(:isThenBranchOf)
ObjectPropertyDomain(:isThenBranchOf :Statement)
ObjectPropertyRange(:isThenBranchOf :IfThenElseStatement)

# Object Property: :isThrownBy (is thrown by)

AnnotationAssertion(rdfs:comment :isThrownBy "The isThrownBy property relates an exception to the executables it is thrown by."@en)
AnnotationAssertion(rdfs:label :isThrownBy "is thrown by"@en)
SubObjectPropertyOf(:isThrownBy :isReferencedBy)
InverseObjectProperties(:isThrownBy :throws)
ObjectPropertyDomain(:isThrownBy :Class)
ObjectPropertyRange(:isThrownBy :Executable)

# Object Property: :isThrownExpressionOf (is thrown expression of)

AnnotationAssertion(rdfs:comment :isThrownExpressionOf "The isThrownExpressionOf property relates a thrown expression, to the throw statement it is contained in."@en)
AnnotationAssertion(rdfs:label :isThrownExpressionOf "is thrown expression of"@en)
SubObjectPropertyOf(:isThrownExpressionOf :isSubExpressionOf)
FunctionalObjectProperty(:isThrownExpressionOf)
InverseFunctionalObjectProperty(:isThrownExpressionOf)
ObjectPropertyDomain(:isThrownExpressionOf :Expression)
ObjectPropertyRange(:isThrownExpressionOf :ThrowStatement)

# Object Property: :isTypeOf (is type of)

AnnotationAssertion(rdfs:comment :isTypeOf "The isTypeOf property relates a type to the elements of that type."@en)
AnnotationAssertion(rdfs:label :isTypeOf "is type of"@en)
InverseFunctionalObjectProperty(:isTypeOf)
ObjectPropertyDomain(:isTypeOf :Type)
ObjectPropertyRange(:isTypeOf ObjectUnionOf(:Expression :Method :Variable))

# Object Property: :overrides (overrides)

AnnotationAssertion(rdfs:comment :overrides "The overrides property relates a method to the method it overrides."@en)
AnnotationAssertion(rdfs:label :overrides "overrides"@en)
SubObjectPropertyOf(:overrides xkos:specializes)
FunctionalObjectProperty(:overrides)
ObjectPropertyDomain(:overrides :Method)
ObjectPropertyRange(:overrides :Method)

# Object Property: :references (references)

AnnotationAssertion(rdfs:comment :references "The references property relates a method or a constructor to the types, methods, constructors and fields it references."@en)
AnnotationAssertion(rdfs:label :references "references"@en)
ObjectPropertyDomain(:references :CodeElement)
ObjectPropertyRange(:references :CodeElement)

# Object Property: :returns (returns)

AnnotationAssertion(rdfs:comment :returns "The returns property relates a method to the variable it returns, if any."@en)
AnnotationAssertion(rdfs:label :returns "returns"@en)
FunctionalObjectProperty(:returns)
ObjectPropertyDomain(:returns :Method)
ObjectPropertyRange(:returns :Variable)

# Object Property: :throws (throws)

AnnotationAssertion(rdfs:comment :throws "The throws property relates a method or a constructor to the exceptions it declares to throw."@en)
AnnotationAssertion(rdfs:label :throws "throws"@en)
SubObjectPropertyOf(:throws :references)
ObjectPropertyDomain(:throws :Executable)
ObjectPropertyRange(:throws :Class)


############################
#   Data Properties
############################

# Data Property: :hasBuildFile (build file)

AnnotationAssertion(rdfs:comment :hasBuildFile "Links a project to the content of its build file.")
AnnotationAssertion(rdfs:label :hasBuildFile "build file")
FunctionalDataProperty(:hasBuildFile)
DataPropertyDomain(:hasBuildFile :Project)
DataPropertyRange(:hasBuildFile xsd:string)

# Data Property: :hasCanonicalName (has canonical name)

AnnotationAssertion(rdfs:comment :hasCanonicalName "Links a class, enum or interface to its canonical name. For instance, the class Java.lang.String is linked to the string \"java.lang.string\""@en)
AnnotationAssertion(rdfs:label :hasCanonicalName "has canonical name"@en)
SubDataPropertyOf(:hasCanonicalName :hasName)
DataPropertyDomain(:hasCanonicalName :ComplexType)
DataPropertyRange(:hasCanonicalName xsd:string)

# Data Property: :hasDimensions (dimensions)

AnnotationAssertion(rdfs:comment :hasDimensions "Links an array to the number of its dimensions. As an example, an array of type \"int[][][]\" has a dimensions count of 3"@en)
AnnotationAssertion(rdfs:label :hasDimensions "dimensions"@en)
FunctionalDataProperty(:hasDimensions)
DataPropertyDomain(:hasDimensions :ArrayType)
DataPropertyRange(:hasDimensions xsd:int)

# Data Property: :hasEndLine (end line)

AnnotationAssertion(rdfs:comment :hasEndLine "Links a statement to the number of the last line it covers"@en)
AnnotationAssertion(rdfs:label :hasEndLine "end line"@en)
FunctionalDataProperty(:hasEndLine)
DataPropertyDomain(:hasEndLine :BlockStatement)
DataPropertyRange(:hasEndLine xsd:int)

# Data Property: :hasLabel (label)

AnnotationAssertion(rdfs:comment :hasLabel "Links a labeled statement to its label"@en)
AnnotationAssertion(rdfs:label :hasLabel "label"@en)
SubDataPropertyOf(:hasLabel owl:topDataProperty)
FunctionalDataProperty(:hasLabel)
DataPropertyDomain(:hasLabel :Statement)
DataPropertyRange(:hasLabel xsd:string)

# Data Property: :hasLine (line)

AnnotationAssertion(rdfs:comment :hasLine "Links a statement to the line it starts in"@en)
AnnotationAssertion(rdfs:label :hasLine "line"@en)
FunctionalDataProperty(:hasLine)
DataPropertyDomain(:hasLine ObjectUnionOf(:Expression :Statement))
DataPropertyRange(:hasLine xsd:int)

# Data Property: :hasName (name)

AnnotationAssertion(rdfs:comment :hasName "Links a element to its name"@en)
AnnotationAssertion(rdfs:label :hasName "name"@en)
FunctionalDataProperty(:hasName)
DataPropertyDomain(:hasName ObjectUnionOf(:CodeElement :Library :Project))
DataPropertyRange(:hasName xsd:string)

# Data Property: :hasPosition (position)

AnnotationAssertion(rdfs:comment :hasPosition "Links a element to its position"@en)
AnnotationAssertion(rdfs:label :hasPosition "position"@en)
FunctionalDataProperty(:hasPosition)
DataPropertyDomain(:hasPosition :CodeElement)
DataPropertyRange(:hasPosition xsd:int)

# Data Property: :hasSimpleName (has simple name)

AnnotationAssertion(rdfs:comment :hasSimpleName "Links a class, enum or interface to its simple name. For instance, the simple name of the class java.lang.String is \"String\""@en)
AnnotationAssertion(rdfs:label :hasSimpleName "has simple name"@en)
SubDataPropertyOf(:hasSimpleName :hasName)
DataPropertyDomain(:hasSimpleName :ComplexType)
DataPropertyRange(:hasSimpleName xsd:string)

# Data Property: :hasSourceCode (source code)

AnnotationAssertion(rdfs:comment :hasSourceCode "Links a element to its source code"@en)
AnnotationAssertion(rdfs:label :hasSourceCode "source code"@en)
FunctionalDataProperty(:hasSourceCode)
DataPropertyDomain(:hasSourceCode :CodeElement)
DataPropertyRange(:hasSourceCode xsd:string)

# Data Property: :hasTargetedLabel (targeted label)

AnnotationAssertion(rdfs:comment :hasTargetedLabel "Links a break statement or a continue statement to the label it targets, if any"@en)
AnnotationAssertion(rdfs:label :hasTargetedLabel "targeted label")
FunctionalDataProperty(:hasTargetedLabel)
DataPropertyDomain(:hasTargetedLabel ObjectUnionOf(:BreakStatement :ContinueStatement))
DataPropertyRange(:hasTargetedLabel xsd:string)

# Data Property: :isVarArgs (is var args)

AnnotationAssertion(rdfs:comment :isVarArgs "True if an executable accepts a variable number of parameters, false otherwise"@en)
AnnotationAssertion(rdfs:label :isVarArgs "is var args"@en)
FunctionalDataProperty(:isVarArgs)
DataPropertyDomain(:isVarArgs :Executable)
DataPropertyRange(:isVarArgs xsd:boolean)



############################
#   Classes
############################

# Class: :AccessModifier (Access Modifier)

AnnotationAssertion(rdfs:comment :AccessModifier "An access modifier"@en)
AnnotationAssertion(rdfs:label :AccessModifier "Access Modifier"@en)
SubClassOf(:AccessModifier :Modifier)

# Class: :ActualArgument (Actual Argument)

AnnotationAssertion(rdfs:comment :ActualArgument "The actual argument of a method")
AnnotationAssertion(rdfs:label :ActualArgument "Actual Argument")
SubClassOf(:ActualArgument :Expression)
SubClassOf(:ActualArgument ObjectExactCardinality(1 :hasSubExpression :Expression))
SubClassOf(:ActualArgument DataExactCardinality(1 :hasPosition xsd:int))

# Class: :AnnotationType (Annotation)

AnnotationAssertion(rdfs:comment :AnnotationType "An annotation"@en)
AnnotationAssertion(rdfs:label :AnnotationType "Annotation"@en)
SubClassOf(:AnnotationType :Type)

# Class: :AnonymousClass (Anonymous Class)

AnnotationAssertion(rdfs:comment :AnonymousClass "An anonymous class"@en)
AnnotationAssertion(rdfs:label :AnonymousClass "Anonymous Class"@en)
SubClassOf(:AnonymousClass :Class)

# Class: :ArrayType (Array)

AnnotationAssertion(rdfs:comment :ArrayType "An array type"@en)
AnnotationAssertion(rdfs:label :ArrayType "Array"@en)
SubClassOf(:ArrayType :Type)
SubClassOf(:ArrayType ObjectExactCardinality(1 :isArrayOf :Type))
SubClassOf(:ArrayType DataExactCardinality(1 :hasDimensions xsd:int))

# Class: :AssertStatement (Assert Statement)

AnnotationAssertion(rdfs:comment :AssertStatement "An assert statement"@en)
AnnotationAssertion(rdfs:label :AssertStatement "Assert Statement"@en)
SubClassOf(:AssertStatement :Statement)
SubClassOf(:AssertStatement ObjectExactCardinality(1 :hasAssertExpression :Expression))

# Class: :AssignmentExpression (Assignment Expression)

AnnotationAssertion(rdfs:comment :AssignmentExpression "An assignment expression. It involves one of the following operators:
=, *=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |="@en)
AnnotationAssertion(rdfs:label :AssignmentExpression "Assignment Expression")
SubClassOf(:AssignmentExpression :Expression)
SubClassOf(:AssignmentExpression ObjectExactCardinality(1 :hasLeftHandSide :Expression))
SubClassOf(:AssignmentExpression ObjectExactCardinality(1 :hasSubExpression :Expression))

# Class: :BlockStatement (Block Statement)

AnnotationAssertion(rdfs:comment :BlockStatement "A block"@en)
AnnotationAssertion(rdfs:label :BlockStatement "Block Statement"@en)
SubClassOf(:BlockStatement :Statement)

# Class: :BranchingStatement (Branching Statement)

AnnotationAssertion(rdfs:comment :BranchingStatement "A branching statement, namely a break statement, a continue statement or a return statement"@en)
AnnotationAssertion(rdfs:label :BranchingStatement "Branching Statement"@en)
SubClassOf(:BranchingStatement :ControlFlowStatement)

# Class: :BreakStatement (Break Statement)

AnnotationAssertion(rdfs:comment :BreakStatement "The BreakStatement class represents a break statement. The break statement has two forms: labeled and unlabeled. In case a break statement is labeled, the label is defined through the targetedLabel property"@en)
AnnotationAssertion(rdfs:label :BreakStatement "Break Statement"@en)
SubClassOf(:BreakStatement :BranchingStatement)

# Class: :CaseLabeledBlock (Case Labeled Block)

AnnotationAssertion(rdfs:comment :CaseLabeledBlock "A case-labeled list of statements"@en)
AnnotationAssertion(rdfs:label :CaseLabeledBlock "Case Labeled Block"@en)
SubClassOf(:CaseLabeledBlock :LabeledBlock)
SubClassOf(:CaseLabeledBlock ObjectExactCardinality(1 :hasSubExpression :Expression))

# Class: :CatchBlock (Catch Block)

AnnotationAssertion(rdfs:comment :CatchBlock "A catch block"@en)
AnnotationAssertion(rdfs:label :CatchBlock "Catch Block"@en)
SubClassOf(:CatchBlock :BlockStatement)
SubClassOf(:CatchBlock ObjectSomeValuesFrom(:hasCatchFormalParameter :Class))

# Class: :Class (Class)

AnnotationAssertion(rdfs:comment :Class "A class"@en)
AnnotationAssertion(rdfs:label :Class "Class"@en)
SubClassOf(:Class :ComplexType)
SubClassOf(:Class ObjectAllValuesFrom(:extends :Class))
SubClassOf(:Class ObjectAllValuesFrom(:hasDeclaration :ClassDeclarationStatement))
SubClassOf(:Class ObjectAllValuesFrom(:implements :Interface))
SubClassOf(:Class ObjectExactCardinality(1 :extends :Class))

# Class: :ClassDeclarationStatement (Class Declaration Statement)

AnnotationAssertion(rdfs:comment :ClassDeclarationStatement "A statement that corresponds to the declaration of a local class"@en)
AnnotationAssertion(rdfs:label :ClassDeclarationStatement "Class Declaration Statement"@en)
SubClassOf(:ClassDeclarationStatement :DeclarationStatement)
DisjointClasses(:ClassDeclarationStatement :VariableDeclarationStatement)

# Class: :ClassInstanceCreationExpression (Class Instance Creation Expression)

AnnotationAssertion(rdfs:comment :ClassInstanceCreationExpression "An expression that creates a class instance, in other words a constructor call"@en)
AnnotationAssertion(rdfs:label :ClassInstanceCreationExpression "Class Instance Creation Expression"@en)
SubClassOf(:ClassInstanceCreationExpression :ExecutableInvocationExpression)
DisjointClasses(:ClassInstanceCreationExpression :MethodInvocationExpression)

# Class: :CodeElement (Code Element)

AnnotationAssertion(rdfs:comment :CodeElement "A generic element in source code"@en)
AnnotationAssertion(rdfs:label :CodeElement "Code Element"@en)

# Class: :ComplexType (Complex Type)

AnnotationAssertion(rdfs:comment :ComplexType "A class or an enumeration or an interface"@en)
AnnotationAssertion(rdfs:label :ComplexType "Complex Type"@en)
SubClassOf(:ComplexType :Modifiable)
SubClassOf(:ComplexType :Type)

# Class: :Constructor (Constructor)

AnnotationAssertion(rdfs:comment :Constructor "A constructor of a Class"@en)
AnnotationAssertion(rdfs:label :Constructor "Constructor"@en)
SubClassOf(:Constructor :Executable)
DisjointClasses(:Constructor :Method)

# Class: :ContinueStatement (Continue Statement)

AnnotationAssertion(rdfs:comment :ContinueStatement "A continue statement"@en)
AnnotationAssertion(rdfs:label :ContinueStatement "Continue Statement"@en)
SubClassOf(:ContinueStatement :BranchingStatement)

# Class: :ControlFlowStatement (Control Flow Statement)

AnnotationAssertion(rdfs:comment :ControlFlowStatement "A control flow statement, that is a statement that regulates the order in which statements are executed.
Control Flow Statements break up the flow of execution by employing decision making, looping, or branching."@en)
AnnotationAssertion(rdfs:label :ControlFlowStatement "Control Flow Statement"@en)
SubClassOf(:ControlFlowStatement :Statement)

# Class: :DecisionMakingStatement (Decision Making Statement)

AnnotationAssertion(rdfs:comment :DecisionMakingStatement "A Decision Making Statement, that is a statement that break up the flow of execution by employing decision making. It can either be a if-then-else statement or a switch statement."@en)
AnnotationAssertion(rdfs:label :DecisionMakingStatement "Decision Making Statement"@en)
SubClassOf(:DecisionMakingStatement :ControlFlowStatement)

# Class: :DeclarationStatement (Declaration statement)

AnnotationAssertion(rdfs:comment :DeclarationStatement "A statement that holds a declaration"@en)
AnnotationAssertion(rdfs:label :DeclarationStatement "Declaration statement"@en)
SubClassOf(:DeclarationStatement :Statement)

# Class: :DefaultLabeledBlock (Default Labeled Block)

AnnotationAssertion(rdfs:comment :DefaultLabeledBlock "A default-labeled block"@en)
AnnotationAssertion(rdfs:label :DefaultLabeledBlock "Default Labeled Block"@en)
SubClassOf(:DefaultLabeledBlock :LabeledBlock)

# Class: :DoStatement (Do Statement)

AnnotationAssertion(rdfs:comment :DoStatement "A do-while statement"@en)
AnnotationAssertion(rdfs:label :DoStatement "Do Statement"@en)
SubClassOf(:DoStatement :LoopStatement)
SubClassOf(:DoStatement ObjectExactCardinality(1 :hasCondition :Expression))

# Class: :Enum (Enum)

AnnotationAssertion(rdfs:comment :Enum "An enumeration"@en)
AnnotationAssertion(rdfs:label :Enum "Enum"@en)
SubClassOf(:Enum :ComplexType)

# Class: :Executable (Executable)

AnnotationAssertion(rdfs:comment :Executable "An executable block of code, namely a Method or a Constructor"@en)
AnnotationAssertion(rdfs:label :Executable "Executable"@en)
SubClassOf(:Executable :CodeElement)
SubClassOf(:Executable :Modifiable)
SubClassOf(:Executable DataSomeValuesFrom(:isVarArgs xsd:boolean))

# Class: :ExecutableInvocationExpression (Executable invocation expression)

AnnotationAssertion(rdfs:comment :ExecutableInvocationExpression "An invocation of either a method or a constructor."@en)
AnnotationAssertion(rdfs:label :ExecutableInvocationExpression "Executable invocation expression"@en)
SubClassOf(:ExecutableInvocationExpression :Expression)
SubClassOf(:ExecutableInvocationExpression ObjectExactCardinality(1 :invokes :Executable))

# Class: :Expression (Expression)

AnnotationAssertion(rdfs:comment :Expression "A generic expression")
AnnotationAssertion(rdfs:label :Expression "Expression")
SubClassOf(:Expression :CodeElement)
SubClassOf(:Expression ObjectExactCardinality(1 :hasType :Type))
SubClassOf(:Expression DataExactCardinality(1 :hasLine xsd:int))

# Class: :ExpressionStatement (Expression statement)

AnnotationAssertion(rdfs:comment :ExpressionStatement "An expression statement. that is a statement that wraps an expression"@en)
AnnotationAssertion(rdfs:label :ExpressionStatement "Expression statement"@en)
SubClassOf(:ExpressionStatement :Statement)
SubClassOf(:ExpressionStatement ObjectExactCardinality(1 :hasSubExpression :Expression))

# Class: :Field (Field)

AnnotationAssertion(rdfs:comment :Field "A class field"@en)
AnnotationAssertion(rdfs:label :Field "Field"@en)
SubClassOf(:Field :Modifiable)
SubClassOf(:Field :Variable)
SubClassOf(:Field ObjectAllValuesFrom(:hasDeclaration :FieldDeclarationStatement))
SubClassOf(:Field ObjectAllValuesFrom(:isDeclaredBy ObjectUnionOf(:Class :Enum :Interface)))

# Class: :FieldDeclarationStatement (Field Declaration)

AnnotationAssertion(rdfs:comment :FieldDeclarationStatement "The declaration of a field"@en)
AnnotationAssertion(rdfs:label :FieldDeclarationStatement "Field Declaration"@en)
SubClassOf(:FieldDeclarationStatement :VariableDeclarationStatement)
DisjointClasses(:FieldDeclarationStatement :LocalVariableDeclarationStatement)

# Class: :FinallyBlock (Finally Block)

AnnotationAssertion(rdfs:comment :FinallyBlock "A finally block"@en)
AnnotationAssertion(rdfs:label :FinallyBlock "Finally Block"@en)
SubClassOf(:FinallyBlock :BlockStatement)

# Class: :ForEachStatement (ForEach Statement)

AnnotationAssertion(rdfs:comment :ForEachStatement "A for-each statement, also known as enhanced for statement"@en)
AnnotationAssertion(rdfs:label :ForEachStatement "ForEach Statement"@en)
SubClassOf(:ForEachStatement :LoopStatement)
SubClassOf(:ForEachStatement ObjectExactCardinality(1 :hasSubExpression :Expression))
SubClassOf(:ForEachStatement ObjectExactCardinality(1 :hasVariable :Variable))

# Class: :ForStatement (For Statement)

AnnotationAssertion(rdfs:comment :ForStatement "A for statement"@en)
AnnotationAssertion(rdfs:label :ForStatement "For Statement"@en)
SubClassOf(:ForStatement :LoopStatement)
SubClassOf(:ForStatement ObjectExactCardinality(1 :hasCondition :Expression))

# Class: :GradleProject (Gradle Project)

AnnotationAssertion(rdfs:comment :GradleProject "A gradle project"@en)
AnnotationAssertion(rdfs:label :GradleProject "Gradle Project"@en)
SubClassOf(:GradleProject :Project)

# Class: :IfThenElseStatement (If-then-else statement)

AnnotationAssertion(rdfs:comment :IfThenElseStatement "A If-then-else statement"@en)
AnnotationAssertion(rdfs:label :IfThenElseStatement "If-then-else statement"@en)
SubClassOf(:IfThenElseStatement :DecisionMakingStatement)
SubClassOf(:IfThenElseStatement ObjectExactCardinality(1 :hasCondition :Expression))
SubClassOf(:IfThenElseStatement ObjectExactCardinality(1 :hasThenBranch :Statement))
DisjointClasses(:IfThenElseStatement :SwitchStatement)

# Class: :Interface (Interface)

AnnotationAssertion(rdfs:comment :Interface "An interface"@en)
AnnotationAssertion(rdfs:label :Interface "Interface"@en)
SubClassOf(:Interface :ComplexType)
SubClassOf(:Interface ObjectAllValuesFrom(:extends :Interface))

# Class: :LabeledBlock (Labeled Block)

AnnotationAssertion(rdfs:comment :LabeledBlock "A labeled block of code, namely a case-labeled block or a default-labeled block"@en)
AnnotationAssertion(rdfs:label :LabeledBlock "Labeled Block"@en)
SubClassOf(:LabeledBlock :BlockStatement)
SubClassOf(:LabeledBlock ObjectAllValuesFrom(:hasNextStatement :LabeledBlock))

# Class: :Library (Library)

AnnotationAssertion(rdfs:comment :Library "A library"@en)
AnnotationAssertion(rdfs:label :Library "Library"@en)
SubClassOf(:Library DataExactCardinality(1 :hasName xsd:string))

# Class: :LocalVariable (Local Variable)

AnnotationAssertion(rdfs:comment :LocalVariable "A local variable"@en)
AnnotationAssertion(rdfs:label :LocalVariable "Local Variable"@en)
SubClassOf(:LocalVariable :Variable)
SubClassOf(:LocalVariable ObjectAllValuesFrom(:isDeclaredBy :Executable))

# Class: :LocalVariableDeclarationStatement (Local Variable Declaration Statement)

AnnotationAssertion(rdfs:comment :LocalVariableDeclarationStatement "A local variable declaration"@en)
AnnotationAssertion(rdfs:label :LocalVariableDeclarationStatement "Local Variable Declaration Statement"@en)
SubClassOf(:LocalVariableDeclarationStatement :VariableDeclarationStatement)

# Class: :LoopStatement (Loop Statement)

AnnotationAssertion(rdfs:comment :LoopStatement "A loop statement."@en)
AnnotationAssertion(rdfs:label :LoopStatement "Loop Statement"@en)
SubClassOf(:LoopStatement :ControlFlowStatement)
SubClassOf(:LoopStatement ObjectMaxCardinality(1 :hasBody :BlockStatement))

# Class: :MavenProject (Maven Project)

AnnotationAssertion(rdfs:comment :MavenProject "A maven project"@en)
AnnotationAssertion(rdfs:label :MavenProject "Maven Project"@en)
SubClassOf(:MavenProject :Project)

# Class: :Method (Method)

AnnotationAssertion(rdfs:comment :Method "A Method"@en)
AnnotationAssertion(rdfs:label :Method "Method"@en)
SubClassOf(:Method :Executable)

# Class: :MethodInvocationExpression (Method Invocation Expression)

AnnotationAssertion(rdfs:comment :MethodInvocationExpression "A method call"@en)
AnnotationAssertion(rdfs:label :MethodInvocationExpression "Method Invocation Expression"@en)
SubClassOf(:MethodInvocationExpression :ExecutableInvocationExpression)

# Class: :Modifiable (Modifiable)

AnnotationAssertion(rdfs:comment :Modifiable "An element that can have a modifier"@en)
AnnotationAssertion(rdfs:label :Modifiable "Modifiable"@en)
SubClassOf(:Modifiable :CodeElement)
SubClassOf(:Modifiable ObjectSomeValuesFrom(:hasModifier :Modifier))
SubClassOf(:Modifiable ObjectExactCardinality(1 :hasModifier :AccessModifier))

# Class: :Modifier (Modifier)

AnnotationAssertion(rdfs:comment :Modifier "A modifier"@en)
AnnotationAssertion(rdfs:label :Modifier "Modifier"@en)
SubClassOf(:Modifier :CodeElement)

# Class: :Package (Package)

AnnotationAssertion(rdfs:comment :Package "A Package"@en)
AnnotationAssertion(rdfs:label :Package "Package"@en)
SubClassOf(:Package :CodeElement)

# Class: :Parameter (Parameter)

AnnotationAssertion(rdfs:comment :Parameter "A formal parameter"@en)
AnnotationAssertion(rdfs:label :Parameter "Parameter"@en)
SubClassOf(:Parameter :Variable)
SubClassOf(:Parameter DataExactCardinality(1 :hasPosition xsd:int))

# Class: :ParameterizedType (Parameterized Type)

AnnotationAssertion(rdfs:comment :ParameterizedType "A parameterized type is a particular parameterization of a generic type denoted by a specified list of type arguments"@en)
AnnotationAssertion(rdfs:label :ParameterizedType "Parameterized Type")
SubClassOf(:ParameterizedType :Type)
SubClassOf(:ParameterizedType ObjectSomeValuesFrom(:hasActualTypeArgument :TypeArgument))
SubClassOf(:ParameterizedType ObjectExactCardinality(1 :hasGenericType :ComplexType))

# Class: :PrimitiveType (Primitive Type)

AnnotationAssertion(rdfs:comment :PrimitiveType "A primitive type")
AnnotationAssertion(rdfs:label :PrimitiveType "Primitive Type")
SubClassOf(:PrimitiveType :Type)

# Class: :Project (Project)

AnnotationAssertion(rdfs:comment :Project "A project"@en)
AnnotationAssertion(rdfs:label :Project "Project"@en)

# Class: :ReturnStatement (Return Statement)

AnnotationAssertion(rdfs:comment :ReturnStatement "A return statement"@en)
AnnotationAssertion(rdfs:label :ReturnStatement "Return Statement"@en)
SubClassOf(:ReturnStatement :BranchingStatement)

# Class: :Statement (Statement)

AnnotationAssertion(rdfs:comment :Statement "A generic statement")
AnnotationAssertion(rdfs:label :Statement "Statement")
SubClassOf(:Statement :CodeElement)
SubClassOf(:Statement DataExactCardinality(1 :hasLine xsd:int))
SubClassOf(:Statement DataExactCardinality(1 :hasPosition xsd:int))

# Class: :SwitchStatement (Switch Statement)

AnnotationAssertion(rdfs:comment :SwitchStatement "A switch statement"@en)
AnnotationAssertion(rdfs:label :SwitchStatement "Switch Statement"@en)
SubClassOf(:SwitchStatement :DecisionMakingStatement)
SubClassOf(:SwitchStatement ObjectExactCardinality(1 :hasSubExpression :Expression))

# Class: :SynchronizedStatement (Synchronized Statement)

AnnotationAssertion(rdfs:comment :SynchronizedStatement "A synchronized statement, that is a statement that acquires a mutual-exclusion lock on behalf of the executiing-thread, executes a block, then release the lock.
In java it is of the form:
synchronized <Expression> <Block>"@en)
AnnotationAssertion(rdfs:label :SynchronizedStatement "Synchronized Statement"@en)
SubClassOf(:SynchronizedStatement :Statement)

# Class: :ThrowStatement (Throw Statement)

AnnotationAssertion(rdfs:comment :ThrowStatement "A throw statement, that is a statement that causes an exception to be thrown"@en)
AnnotationAssertion(rdfs:label :ThrowStatement "Throw Statement"@en)
SubClassOf(:ThrowStatement :Statement)
SubClassOf(:ThrowStatement ObjectExactCardinality(1 :hasThrownExpression :Expression))

# Class: :TryStatement (Try Statement)

AnnotationAssertion(rdfs:comment :TryStatement "A try statement"@en)
AnnotationAssertion(rdfs:label :TryStatement "Try Statement"@en)
SubClassOf(:TryStatement :Statement)
SubClassOf(:TryStatement ObjectMaxCardinality(1 :hasBody :BlockStatement))

# Class: :Type (Type)

AnnotationAssertion(rdfs:comment :Type "A type"@en)
AnnotationAssertion(rdfs:label :Type "Type"@en)
SubClassOf(:Type :CodeElement)

# Class: :TypeArgument (Type Argument)

AnnotationAssertion(rdfs:comment :TypeArgument "This class defines the actual type argument of a parameterized type"@en)
AnnotationAssertion(rdfs:label :TypeArgument "Type Argument"@en)
SubClassOf(:TypeArgument :CodeElement)

# Class: :TypeVariable (Type Variable)

AnnotationAssertion(rdfs:comment :TypeVariable "A type variable is an unqualified identifier used as a type. It is introduced by the declaration of a generic class, interface, method, or constructor"@en)
AnnotationAssertion(rdfs:label :TypeVariable "Type Variable")
SubClassOf(:TypeVariable :Type)
SubClassOf(:TypeVariable ObjectAllValuesFrom(:extends ObjectUnionOf(:Class :Interface :ParameterizedType)))

# Class: :Variable (Variable)

AnnotationAssertion(rdfs:comment :Variable "A variable"@en)
AnnotationAssertion(rdfs:label :Variable "Variable"@en)
SubClassOf(:Variable :CodeElement)
SubClassOf(:Variable ObjectExactCardinality(1 :hasType :Type))

# Class: :VariableDeclarationStatement (Variable Declaration)

AnnotationAssertion(rdfs:comment :VariableDeclarationStatement "A statement that represents the declaration of a variable"@en)
AnnotationAssertion(rdfs:label :VariableDeclarationStatement "Variable Declaration"@en)
SubClassOf(:VariableDeclarationStatement :DeclarationStatement)

# Class: :WhileStatement (While Statement)

AnnotationAssertion(rdfs:comment :WhileStatement "A while statement"@en)
AnnotationAssertion(rdfs:label :WhileStatement "While Statement"@en)
SubClassOf(:WhileStatement :LoopStatement)
SubClassOf(:WhileStatement ObjectExactCardinality(1 :hasCondition :Expression))

# Class: :Wildcard (Wildcard)

AnnotationAssertion(rdfs:comment :Wildcard "A wildcard"@en)
AnnotationAssertion(rdfs:label :Wildcard "Wildcard"@en)
SubClassOf(:Wildcard :Type)
SubClassOf(:Wildcard ObjectAllValuesFrom(:extends ObjectUnionOf(:Class :Interface :ParameterizedType)))
SubClassOf(:Wildcard ObjectAllValuesFrom(:hasSuperBound :Type))


############################
#   Named Individuals
############################

# Individual: :Abstract (Abstract)

AnnotationAssertion(rdfs:comment :Abstract "The abstract modifier"@en)
AnnotationAssertion(rdfs:label :Abstract "Abstract"@en)
ClassAssertion(:Modifier :Abstract)

# Individual: :Boolean (Boolean)

AnnotationAssertion(rdfs:comment :Boolean "The boolean type"@en)
AnnotationAssertion(rdfs:label :Boolean "Boolean"@en)
ClassAssertion(:PrimitiveType :Boolean)

# Individual: :Byte (Byte)

AnnotationAssertion(rdfs:comment :Byte "The byte type"@en)
AnnotationAssertion(rdfs:label :Byte "Byte"@en)
ClassAssertion(:PrimitiveType :Byte)

# Individual: :Char (Char)

AnnotationAssertion(rdfs:comment :Char "The char type"@en)
AnnotationAssertion(rdfs:label :Char "Char"@en)
ClassAssertion(:PrimitiveType :Char)

# Individual: :Default (Default)

AnnotationAssertion(rdfs:comment :Default "The default modifier"@en)
AnnotationAssertion(rdfs:label :Default "Default"@en)
ClassAssertion(:AccessModifier :Default)

# Individual: :Double (Double)

AnnotationAssertion(rdfs:comment :Double "The double type"@en)
AnnotationAssertion(rdfs:label :Double "Double"@en)
ClassAssertion(:PrimitiveType :Double)

# Individual: :Final (Final)

AnnotationAssertion(rdfs:comment :Final "The final modifier"@en)
AnnotationAssertion(rdfs:label :Final "Final"@en)
ClassAssertion(:Modifier :Final)

# Individual: :Float (Float)

AnnotationAssertion(rdfs:comment :Float "The float type"@en)
AnnotationAssertion(rdfs:label :Float "Float"@en)
ClassAssertion(:PrimitiveType :Float)

# Individual: :Int (Int)

AnnotationAssertion(rdfs:comment :Int "The int type"@en)
AnnotationAssertion(rdfs:label :Int "Int"@en)
ClassAssertion(:PrimitiveType :Int)

# Individual: :Long (Long)

AnnotationAssertion(rdfs:comment :Long "The long type"@en)
AnnotationAssertion(rdfs:label :Long "Long"@en)
ClassAssertion(:PrimitiveType :Long)

# Individual: :Private (Private)

AnnotationAssertion(rdfs:comment :Private "The private modifier"@en)
AnnotationAssertion(rdfs:label :Private "Private"@en)
ClassAssertion(:AccessModifier :Private)

# Individual: :Protected (Protected)

AnnotationAssertion(rdfs:comment :Protected "The protected modifier"@en)
AnnotationAssertion(rdfs:label :Protected "Protected"@en)
ClassAssertion(:AccessModifier :Protected)

# Individual: :Public (Public)

AnnotationAssertion(rdfs:comment :Public "The public modifier"@en)
AnnotationAssertion(rdfs:label :Public "Public"@en)
ClassAssertion(:AccessModifier :Public)

# Individual: :Short (Short)

AnnotationAssertion(rdfs:comment :Short "The short type"@en)
AnnotationAssertion(rdfs:label :Short "Short"@en)
ClassAssertion(:PrimitiveType :Short)

# Individual: :Static (Static)

AnnotationAssertion(rdfs:comment :Static "The static modifier"@en)
AnnotationAssertion(rdfs:label :Static "Static"@en)
ClassAssertion(:Modifier :Static)

# Individual: :Synchronized (Synchronized)

AnnotationAssertion(rdfs:comment :Synchronized "The synchronized modifier"@en)
AnnotationAssertion(rdfs:label :Synchronized "Synchronized"@en)
ClassAssertion(:Modifier :Synchronized)

# Individual: :Volatile (Volatile)

AnnotationAssertion(rdfs:comment :Volatile "The volatile modifier"@en)
AnnotationAssertion(rdfs:label :Volatile "Volatile"@en)
ClassAssertion(:Modifier :Volatile)


DisjointClasses(:ActualArgument :AssignmentExpression :ExecutableInvocationExpression)
DisjointClasses(:AnnotationType :ArrayType :ComplexType :ParameterizedType :PrimitiveType :TypeVariable :Wildcard)
DisjointClasses(:AssertStatement :BlockStatement :ControlFlowStatement :DeclarationStatement :ExpressionStatement :SynchronizedStatement :ThrowStatement :TryStatement)
DisjointClasses(:BranchingStatement :DecisionMakingStatement :LoopStatement)
DisjointClasses(:BreakStatement :ContinueStatement :ReturnStatement)
DisjointClasses(:CatchBlock :FinallyBlock :LabeledBlock)
DisjointClasses(:Class :Enum :Interface)
DisjointClasses(:CodeElement :Library :Project)
DisjointClasses(:DoStatement :ForEachStatement :ForStatement :WhileStatement)
DisjointClasses(:Executable :Expression :Modifier :Package :Statement :Type :TypeArgument :Variable)
DisjointClasses(:Field :LocalVariable :Parameter)
DifferentIndividuals(:Abstract :Boolean :Byte :Char :Default :Double :Final :Float :Int :Long :Private :Protected :Public :Short :Static :Synchronized :Volatile)
)